/**
 * RateWise Custom Service Worker
 *
 * Purpose: Proper offline fallback using Workbox setCatchHandler
 * Issue: generateSW mode's navigateFallback points to index.html which needs network
 * Solution: Use injectManifest + setCatchHandler to serve /offline.html directly
 *
 * References:
 * - [context7:workbox/workbox:2025-01-09] setCatchHandler API
 * - [context7:vite-pwa/vite-plugin-pwa:2025-01-09] injectManifest mode
 * - Safari iOS PWA best practices (50MB cache limit, 7-day storage cap)
 */

/// <reference lib="webworker" />

import {
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
  matchPrecache,
  precacheAndRoute,
} from 'workbox-precaching';
import { NavigationRoute, registerRoute, setCatchHandler } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope & typeof globalThis;

// Precache all assets generated by Vite build
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches from previous versions
cleanupOutdatedCaches();

// Enable clients claim and skip waiting for immediate activation
void self.skipWaiting();
void self.clients.claim();

// =============================================================================
// [fix:2026-01-09] Critical Fix: Offline Navigation Fallback
// =============================================================================
// Problem: navigateFallback to index.html doesn't work offline
// Root cause: index.html requires JavaScript bundles and API calls to render
// Solution: setCatchHandler to serve /offline.html on navigation errors
// =============================================================================

// Navigation Route: Handle SPA navigation with proper denylist
const navigationRoute = new NavigationRoute(createHandlerBoundToURL('/index.html'), {
  denylist: [
    /^\/api/, // API endpoints
    /^\/rates/, // Historical rates JSON
    /\.[a-zA-Z0-9]+$/, // Files with extensions (except HTML)
    /\/sw\.js$/, // Service Worker itself
    /\/workbox-.*\.js$/, // Workbox runtime files
  ],
});
registerRoute(navigationRoute);

// =============================================================================
// Critical: Catch Handler for Offline Navigation
// =============================================================================
// When navigation fails (offline or network error), serve offline.html
// This is the proper way according to Workbox official documentation
// Reference: https://developer.chrome.com/docs/workbox/modules/workbox-routing#set-a-catch-handler
//
// [fix:2026-01-09] 使用 matchPrecache 替代 caches.match
// 原因：caches.match('/offline.html') 使用絕對路徑，但當 base 是 /ratewise/ 時，
// 預快取的實際 URL 是 /ratewise/offline.html，導致快取未命中
// matchPrecache 會自動處理 base path 和 revision 參數
setCatchHandler(async ({ event }): Promise<Response> => {
  // Type assertion: Workbox's setCatchHandler passes FetchEvent
  const fetchEvent = event as FetchEvent;

  // Only handle document (navigation) requests
  if (fetchEvent.request.destination === 'document') {
    // 使用 matchPrecache 查找預快取的 offline.html
    // matchPrecache 會自動處理 URL 映射和 revision 查找
    const offlineResponse = await matchPrecache('offline.html');
    if (offlineResponse) {
      return offlineResponse;
    }

    // Fallback: 嘗試使用 SW scope 構建完整 URL
    const scope = self.registration.scope;
    const offlineUrl = new URL('offline.html', scope).href;
    const fallbackResponse = await caches.match(offlineUrl);
    if (fallbackResponse) {
      return fallbackResponse;
    }

    return Response.error();
  }

  // For other request types, return error
  return Response.error();
});

// =============================================================================
// Runtime Caching Strategies (from original vite.config.ts)
// =============================================================================

// HTML: NetworkFirst with 2s timeout (Safari-friendly)
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'document',
  new NetworkFirst({
    cacheName: 'html-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
    networkTimeoutSeconds: 2,
  }),
);

// Historical rates (CDN): CacheFirst for immutable data
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://cdn.jsdelivr.net' &&
    url.pathname.includes('/public/rates/history/') &&
    url.pathname.endsWith('.json'),
  new CacheFirst({
    cacheName: 'history-rates-cdn',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 180,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
);

// Historical rates (Raw fallback): CacheFirst
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://raw.githubusercontent.com' &&
    url.pathname.includes('/public/rates/history/') &&
    url.pathname.endsWith('.json'),
  new CacheFirst({
    cacheName: 'history-rates-raw',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 180,
        maxAgeSeconds: 60 * 60 * 24 * 365,
      }),
    ],
  }),
);

// Latest rates: StaleWhileRevalidate for fast display + background update
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://raw.githubusercontent.com' &&
    url.pathname.includes('/public/rates/latest.json'),
  new StaleWhileRevalidate({
    cacheName: 'latest-rate-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 60 * 5, // 5 minutes
      }),
    ],
  }),
);

// Images: CacheFirst with AVIF/WebP support
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 150,
        maxAgeSeconds: 60 * 60 * 24 * 90, // 90 days
      }),
    ],
  }),
);

// Fonts: CacheFirst for long-term caching
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'font-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
);

// JS/CSS: NetworkFirst to ensure latest version (Vite hash-based filenames)
registerRoute(
  ({ request }: { request: Request }) =>
    request.destination === 'script' || request.destination === 'style',
  new NetworkFirst({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
    networkTimeoutSeconds: 3,
  }),
);

// Manifest/SEO files: StaleWhileRevalidate
registerRoute(
  ({ url }: { url: URL }) => /\.(webmanifest|txt|xml)$/.test(url.pathname),
  new StaleWhileRevalidate({
    cacheName: 'seo-files-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  }),
);

// Offline fallback: CacheFirst for instant offline availability
registerRoute(
  ({ url }: { url: URL }) => url.pathname === '/offline.html',
  new CacheFirst({
    cacheName: 'offline-fallback',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  }),
);

// Service Worker initialization complete (use browser DevTools to debug)
