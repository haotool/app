/**
 * RateWise Custom Service Worker
 *
 * Purpose: Proper offline fallback using Workbox setCatchHandler
 * Issue: generateSW mode's navigateFallback points to index.html which needs network
 * Solution: Use injectManifest + setCatchHandler to serve /offline.html directly
 *
 * References:
 * - [context7:workbox/workbox:2025-01-09] setCatchHandler API
 * - [context7:vite-pwa/vite-plugin-pwa:2025-01-09] injectManifest mode
 * - Safari iOS PWA best practices (50MB cache limit, 7-day storage cap)
 */

/// <reference lib="webworker" />

// [fix:2026-01-11] Workbox location polyfill
// Service Workers 沒有 location 全域變數，但 Workbox 需要 location.href
// 解決方案：使用 post-build script (scripts/patch-sw.mjs) 在編譯後注入 polyfill
// 此方法確保 polyfill 在 IIFE 外部執行，才能被內部代碼訪問
// Reference: [MDN: ServiceWorkerGlobalScope] [Vite Issue #12611]

import {
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
  matchPrecache,
  precacheAndRoute,
} from 'workbox-precaching';
import { NavigationRoute, registerRoute, setCatchHandler } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope & typeof globalThis;

// Precache all assets generated by Vite build
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches from previous versions
cleanupOutdatedCaches();

// [fix:2026-01-10] Service Worker 立即激活（vite-plugin-pwa 官方寫法）
// 根據 vite-plugin-pwa 官方文檔：直接呼叫 skipWaiting() 而非在 event listener 中
// Reference: [context7:/vite-pwa/vite-plugin-pwa:2026-01-10]
void self.skipWaiting();

// =============================================================================
// [fix:2026-01-10] 動態獲取 base path，修復路徑硬編碼問題
// =============================================================================
// 問題：原先使用 '/index.html' 和 '/offline.html' 硬編碼路徑
// 在生產環境 base 為 '/ratewise/' 時會導致路徑不匹配
// 解決方案：使用 self.registration.scope 動態計算 base path
// =============================================================================

/**
 * 從 Service Worker scope 提取 base path
 * @example
 *   scope: 'https://example.com/ratewise/' -> '/ratewise/'
 *   scope: 'https://example.com/' -> '/'
 */
function getBasePath(): string {
  try {
    const scopeUrl = new URL(self.registration.scope);
    return scopeUrl.pathname; // 例如 '/ratewise/' 或 '/'
  } catch {
    return '/'; // fallback
  }
}

/**
 * 將相對路徑轉換為基於 scope 的完整路徑
 * @param relativePath - 相對路徑（如 'index.html'）
 * @returns 完整路徑（如 '/ratewise/index.html'）
 */
function resolvePath(relativePath: string): string {
  const basePath = getBasePath();
  // 移除相對路徑開頭的斜線（如果有）
  const cleanPath = relativePath.startsWith('/') ? relativePath.slice(1) : relativePath;
  return `${basePath}${cleanPath}`;
}

// =============================================================================
// [fix:2026-01-09] Critical Fix: Offline Navigation Fallback
// =============================================================================
// Problem: navigateFallback to index.html doesn't work offline
// Root cause: index.html requires JavaScript bundles and API calls to render
// Solution: setCatchHandler to serve /offline.html on navigation errors
// =============================================================================

// [fix:2026-01-10] 使用動態路徑替代硬編碼
const indexHtmlPath = resolvePath('index.html');

// Navigation Route: Handle SPA navigation with proper denylist
const navigationRoute = new NavigationRoute(createHandlerBoundToURL(indexHtmlPath), {
  denylist: [
    /^\/api/, // API endpoints
    /^\/rates/, // Historical rates JSON
    /\.[a-zA-Z0-9]+$/, // Files with extensions (except HTML)
    /\/sw\.js$/, // Service Worker itself
    /\/workbox-.*\.js$/, // Workbox runtime files
  ],
});
registerRoute(navigationRoute);

// =============================================================================
// Critical: Catch Handler for Offline Navigation
// =============================================================================
// When navigation fails (offline or network error), serve offline.html
// This is the proper way according to Workbox official documentation
// Reference: https://developer.chrome.com/docs/workbox/modules/workbox-routing#set-a-catch-handler
//
// [fix:2026-01-09] 使用 matchPrecache 替代 caches.match
// 原因：caches.match('/offline.html') 使用絕對路徑，但當 base 是 /ratewise/ 時，
// 預快取的實際 URL 是 /ratewise/offline.html，導致快取未命中
// matchPrecache 會自動處理 base path 和 revision 參數
setCatchHandler(async ({ event }): Promise<Response> => {
  // Type assertion: Workbox's setCatchHandler passes FetchEvent
  const fetchEvent = event as FetchEvent;

  // Only handle document (navigation) requests
  if (fetchEvent.request.destination === 'document') {
    // 使用 matchPrecache 查找預快取的 offline.html
    // matchPrecache 會自動處理 URL 映射和 revision 查找
    const offlineResponse = await matchPrecache('offline.html');
    if (offlineResponse) {
      return offlineResponse;
    }

    // Fallback: 嘗試使用 SW scope 構建完整 URL
    const scope = self.registration.scope;
    const offlineUrl = new URL('offline.html', scope).href;
    const fallbackResponse = await caches.match(offlineUrl);
    if (fallbackResponse) {
      return fallbackResponse;
    }

    return Response.error();
  }

  // For other request types, return error
  return Response.error();
});

// =============================================================================
// Runtime Caching Strategies (from original vite.config.ts)
// =============================================================================

// HTML: NetworkFirst with 2s timeout (Safari-friendly)
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'document',
  new NetworkFirst({
    cacheName: 'html-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
    networkTimeoutSeconds: 2,
  }),
);

// Historical rates (CDN): CacheFirst for immutable data
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://cdn.jsdelivr.net' &&
    url.pathname.includes('/public/rates/history/') &&
    url.pathname.endsWith('.json'),
  new CacheFirst({
    cacheName: 'history-rates-cdn',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 180,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
);

// Historical rates (Raw fallback): CacheFirst
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://raw.githubusercontent.com' &&
    url.pathname.includes('/public/rates/history/') &&
    url.pathname.endsWith('.json'),
  new CacheFirst({
    cacheName: 'history-rates-raw',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 180,
        maxAgeSeconds: 60 * 60 * 24 * 365,
      }),
    ],
  }),
);

// Latest rates: StaleWhileRevalidate for fast display + background update
// [fix:2026-01-11] 延長 SW Cache 過期時間至 7 天，作為離線 fallback
// 注意：應用層 localStorage 仍使用 5 分鐘有效期控制新鮮度
// SW Cache 僅作為離線時的最後防線，確保冷啟動後仍能顯示數據
// Safari PWA 離線問題參考: [Apple Developer Forums: Safari iOS PWA Data Persistence]
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://raw.githubusercontent.com' &&
    url.pathname.includes('/public/rates/latest.json'),
  new StaleWhileRevalidate({
    cacheName: 'latest-rate-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days (offline fallback)
      }),
    ],
  }),
);

// Images: CacheFirst with AVIF/WebP support
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 150,
        maxAgeSeconds: 60 * 60 * 24 * 90, // 90 days
      }),
    ],
  }),
);

// Fonts: CacheFirst for long-term caching
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'font-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
);

// JS/CSS: NetworkFirst to ensure latest version (Vite hash-based filenames)
registerRoute(
  ({ request }: { request: Request }) =>
    request.destination === 'script' || request.destination === 'style',
  new NetworkFirst({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
    networkTimeoutSeconds: 3,
  }),
);

// Manifest/SEO files: StaleWhileRevalidate
registerRoute(
  ({ url }: { url: URL }) => /\.(webmanifest|txt|xml)$/.test(url.pathname),
  new StaleWhileRevalidate({
    cacheName: 'seo-files-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  }),
);

// Offline fallback: CacheFirst for instant offline availability
// [fix:2026-01-10] 使用動態路徑匹配，支援不同 base path
registerRoute(
  ({ url }: { url: URL }) => {
    const offlinePath = resolvePath('offline.html');
    return url.pathname === offlinePath;
  },
  new CacheFirst({
    cacheName: 'offline-fallback',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  }),
);

// Service Worker initialization complete (use browser DevTools to debug)
