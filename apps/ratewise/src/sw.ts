/**
 * RateWise Custom Service Worker
 *
 * Purpose: Proper offline fallback using Workbox setCatchHandler
 * Issue: generateSW mode's navigateFallback points to index.html which needs network
 * Solution: Use injectManifest + setCatchHandler to serve /offline.html directly
 *
 * References:
 * - [context7:workbox/workbox:2025-01-09] setCatchHandler API
 * - [context7:vite-pwa/vite-plugin-pwa:2025-01-09] injectManifest mode
 * - Safari iOS PWA best practices (50MB cache limit, 7-day storage cap)
 */

/// <reference lib="webworker" />

// Workbox location polyfill for Service Worker environment
// 解決方案：使用 post-build script (scripts/patch-sw.mjs) 在編譯後注入 polyfill
// 此方法確保 polyfill 在 IIFE 外部執行，才能被內部代碼訪問
// Reference: [MDN: ServiceWorkerGlobalScope] [Vite Issue #12611]

import { clientsClaim } from 'workbox-core';
import {
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
  matchPrecache,
  precacheAndRoute,
} from 'workbox-precaching';
import { NavigationRoute, registerRoute, setCatchHandler } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope & typeof globalThis;

// Precache all assets generated by Vite build
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches from previous versions
cleanupOutdatedCaches();

// Service Worker immediate activation + client claim
// 問題：用戶滑掉 app 後，SW 不會自動重新控制頁面，導致離線功能失效
// 原因：缺少 clientsClaim()，SW 只會控制「在 SW 激活後打開的頁面」
// 解決：同時使用 skipWaiting() + clientsClaim()
//
// skipWaiting(): 跳過等待階段，新 SW 立即激活
// clientsClaim(): 激活後立即控制所有已打開的 Client（包括 iOS Safari 重啟後的頁面）
//
// Reference:
// - [context7:/googlechrome/workbox:2026-01-14] skipWaiting + clientsClaim
// - [context7:/vite-pwa/vite-plugin-pwa:2026-01-14] autoUpdate behavior
// - [Apple Developer Forums] iOS Safari PWA service worker killed after app close
// =============================================================================
void self.skipWaiting();
clientsClaim();

// Dynamic base path resolution
// 問題：原先使用 '/index.html' 和 '/offline.html' 硬編碼路徑
// 在生產環境 base 為 '/ratewise/' 時會導致路徑不匹配
// 解決方案：使用 self.registration.scope 動態計算 base path
// =============================================================================

/**
 * 從 Service Worker scope 提取 base path
 * @example
 *   scope: 'https://example.com/ratewise/' -> '/ratewise/'
 *   scope: 'https://example.com/' -> '/'
 *
 * Safari 防禦：strict URL validation
 * Safari PWA 對 URL 驗證嚴格，必須驗證輸入格式避免 SyntaxError
 * Reference: [context7:w3c/ServiceWorker:2026-02-08]
 */
function getBasePath(): string {
  try {
    // Safari 防禦：驗證 scope 格式
    const scope = self.registration?.scope;
    if (!scope || typeof scope !== 'string' || scope.trim() === '') {
      return '/';
    }

    const scopeUrl = new URL(scope);
    return scopeUrl.pathname; // 例如 '/ratewise/' 或 '/'
  } catch (error) {
    // Safari 可能拋出 "The string did not match the expected pattern"
    console.error('[SW] getBasePath failed:', error);
    return '/'; // fallback
  }
}

/**
 * 將相對路徑轉換為基於 scope 的完整路徑
 * @param relativePath - 相對路徑（如 'index.html'）
 * @returns 完整路徑（如 '/ratewise/index.html'）
 */
function resolvePath(relativePath: string): string {
  const basePath = getBasePath();
  // 移除相對路徑開頭的斜線（如果有）
  const cleanPath = relativePath.startsWith('/') ? relativePath.slice(1) : relativePath;
  return `${basePath}${cleanPath}`;
}

// Offline Navigation Fallback
// Problem: navigateFallback to index.html doesn't work offline
// Root cause: index.html requires JavaScript bundles and API calls to render
// Solution: setCatchHandler to serve /offline.html on navigation errors
// =============================================================================

// Use dynamic path instead of hardcoded
const indexHtmlPath = resolvePath('index.html');

// Navigation Route: Handle SPA navigation with proper denylist
const navigationRoute = new NavigationRoute(createHandlerBoundToURL(indexHtmlPath), {
  denylist: [
    /^\/api/, // API endpoints
    /^\/rates/, // Historical rates JSON
    /\.[a-zA-Z0-9]+$/, // Files with extensions (except HTML)
    /\/sw\.js$/, // Service Worker itself
    /\/workbox-.*\.js$/, // Workbox runtime files
  ],
});
registerRoute(navigationRoute);

// =============================================================================
// Critical: Catch Handler for Offline Navigation
// =============================================================================
// 問題：原先使用 resolvePath 返回完整路徑，但 precache manifest 使用相對路徑
// 解決：matchPrecache 使用相對路徑（與 manifest 一致），caches.match 使用完整 URL
//
// 離線優先策略（4 步驟）：
// 1. 安全性驗證：僅處理同源 document 請求
// 2. runtime cache: 從 html-cache 獲取當前頁面（NetworkFirst 策略）
// 3. precache: 使用相對路徑 'index.html'（與 manifest 一致）
// 4. fallback: 使用相對路徑 'offline.html'
//
// Reference: [context7:/googlechrome/workbox:2026-01-31] matchPrecache uses manifest paths
setCatchHandler(async ({ event, request }): Promise<Response> => {
  const fetchEvent = event as FetchEvent;
  const req = request ?? fetchEvent.request;

  // 僅處理 document (navigation) 請求
  if (req.destination !== 'document') {
    return Response.error();
  }

  // 安全性驗證：僅處理同源請求
  // Safari 防禦：URL 驗證失敗時返回錯誤避免崩潰
  // Safari PWA 對 URL 格式驗證嚴格，必須防禦性檢查
  let requestOrigin: string;
  let swOrigin: string;
  try {
    // Safari 防禦：驗證 URL 格式
    if (!req.url || typeof req.url !== 'string' || req.url.trim() === '') {
      return Response.error();
    }
    const scope = self.registration?.scope;
    if (!scope || typeof scope !== 'string' || scope.trim() === '') {
      return Response.error();
    }

    requestOrigin = new URL(req.url).origin;
    swOrigin = new URL(scope).origin;
  } catch (error) {
    // Safari 可能拋出 "The string did not match the expected pattern"
    console.error('[SW] Origin validation failed:', error);
    return Response.error();
  }
  if (requestOrigin !== swOrigin) {
    return Response.error();
  }

  // 1. 嘗試從 runtime cache 獲取當前頁面
  // Safari 防禦：URL 解析失敗時跳過此步驟
  try {
    // Safari 防禦：驗證 URL 格式
    if (!req.url || typeof req.url !== 'string' || req.url.trim() === '') {
      throw new Error('Invalid URL');
    }

    const requestUrl = new URL(req.url);
    // 防禦深度：驗證路徑不包含路徑遍歷字元
    if (!requestUrl.pathname.includes('..')) {
      const cachedHtml = await caches.match(req.url);
      if (cachedHtml) {
        return cachedHtml;
      }
    }
  } catch (error) {
    // Safari 可能拋出 "The string did not match the expected pattern"
    console.error('[SW] Runtime cache match failed:', error);
    // 快取讀取失敗，繼續嘗試其他快取
  }

  // 2. 嘗試從 precache 獲取 index.html（SPA 入口）
  // 重要：matchPrecache 使用 manifest 中的相對路徑格式
  const indexHtml = await matchPrecache('index.html');
  if (indexHtml) {
    return indexHtml;
  }

  // 3. 嘗試使用完整 URL 匹配 index.html（備用）
  // Safari 防禦：URL 建構失敗時跳過此步驟
  try {
    // Safari 防禦：驗證 scope 格式
    const scope = self.registration?.scope;
    if (!scope || typeof scope !== 'string' || scope.trim() === '') {
      throw new Error('Invalid scope');
    }

    const indexUrl = new URL('index.html', scope).href;
    const indexFromCache = await caches.match(indexUrl);
    if (indexFromCache) {
      return indexFromCache;
    }
  } catch (error) {
    // Safari 可能拋出 "The string did not match the expected pattern"
    console.error('[SW] Index URL construction failed:', error);
    // 快取讀取失敗，繼續嘗試其他快取
  }

  // 4. 最終 fallback：offline.html
  // 重要：matchPrecache 使用 manifest 中的相對路徑格式
  const offlineResponse = await matchPrecache('offline.html');
  if (offlineResponse) {
    return offlineResponse;
  }

  // 備用：嘗試完整 URL 匹配 offline.html
  // Safari 防禦：URL 建構失敗時直接返回錯誤
  try {
    const scope = self.registration?.scope;
    if (!scope || typeof scope !== 'string' || scope.trim() === '') {
      return Response.error();
    }

    const offlineUrl = new URL('offline.html', scope).href;
    const fallbackResponse = await caches.match(offlineUrl);
    if (fallbackResponse) {
      return fallbackResponse;
    }
  } catch (error) {
    // Safari 可能拋出 "The string did not match the expected pattern"
    console.error('[SW] Offline URL construction failed:', error);
  }

  return Response.error();
});

// =============================================================================
// Runtime Caching Strategies (from original vite.config.ts)
// =============================================================================

// HTML: NetworkFirst with 2s timeout (Safari-friendly)
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'document',
  new NetworkFirst({
    cacheName: 'html-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
    networkTimeoutSeconds: 2,
  }),
);

// Historical rates (CDN): CacheFirst for immutable data
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://cdn.jsdelivr.net' &&
    url.pathname.includes('/public/rates/history/') &&
    url.pathname.endsWith('.json'),
  new CacheFirst({
    cacheName: 'history-rates-cdn',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 180,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
);

// Historical rates (Raw fallback): CacheFirst
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://raw.githubusercontent.com' &&
    url.pathname.includes('/public/rates/history/') &&
    url.pathname.endsWith('.json'),
  new CacheFirst({
    cacheName: 'history-rates-raw',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 180,
        maxAgeSeconds: 60 * 60 * 24 * 365,
      }),
    ],
  }),
);

// Latest rates: StaleWhileRevalidate for fast display + background update
// Cache expiry 7 days as offline fallback; app layer uses 5-min freshness
// SW Cache 僅作為離線時的最後防線，確保冷啟動後仍能顯示數據
// Safari PWA 離線問題參考: [Apple Developer Forums: Safari iOS PWA Data Persistence]
registerRoute(
  ({ url }: { url: URL }) =>
    url.origin === 'https://raw.githubusercontent.com' &&
    url.pathname.includes('/public/rates/latest.json'),
  new StaleWhileRevalidate({
    cacheName: 'latest-rate-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days (offline fallback)
      }),
    ],
  }),
);

// Images: CacheFirst with AVIF/WebP support
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 150,
        maxAgeSeconds: 60 * 60 * 24 * 90, // 90 days
      }),
    ],
  }),
);

// Fonts: CacheFirst for long-term caching
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'font-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
);

// JS/CSS: CacheFirst — Vite hash-based filenames are immutable
// 檔名含 content hash（例如 index-a1b2c3.js），相同 hash = 相同內容
// 不需要每次重新驗證，離線時也能立即載入
registerRoute(
  ({ request }: { request: Request }) =>
    request.destination === 'script' || request.destination === 'style',
  new CacheFirst({
    cacheName: 'static-resources',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  }),
);

// Manifest/SEO files: StaleWhileRevalidate
registerRoute(
  ({ url }: { url: URL }) => /\.(webmanifest|txt|xml)$/.test(url.pathname),
  new StaleWhileRevalidate({
    cacheName: 'seo-files-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  }),
);

// offline.html 由 precacheAndRoute 管理（透過 additionalManifestEntries 加入）
// 不需要額外的 runtime route，避免冗餘快取浪費 Safari iOS 50MB 限制

// Service Worker initialization complete (use browser DevTools to debug)
